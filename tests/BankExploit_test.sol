// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "remix_tests.sol"; 
import "../contracts/BankExploit.sol";
import "../contracts/VulnerableBank.sol";
import "./LegitimateBankCustomer.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "hardhat/console.sol";


contract BankExploitTest is Ownable, ReentrancyGuard {
    VulnerableBank private vulnerableBank;
    LegitimateBankCustomer private legitimateCustomer;
    BankExploit private bankExploit;

    constructor() Ownable(msg.sender) {}

    receive() external payable {}

    ///#value: 2000
    function beforeAll() external payable onlyOwner nonReentrant {
        Assert.equal(msg.value, 2000 wei, "Unexpected amount of ETH received");
        
        console.log("Deploying vulnerable bank");
        vulnerableBank = new VulnerableBank();
        
        console.log("Deploying legitimate bank customer");
        legitimateCustomer = new LegitimateBankCustomer{value: 1000 wei}(vulnerableBank);
        Assert.equal(address(legitimateCustomer).balance, 1000 wei, "Unexpected customer balance");
        
        console.log("Deploying bank exploit");
        bankExploit = new BankExploit{value: 1000 wei}(vulnerableBank);
        Assert.equal(address(bankExploit).balance, 1000 wei, "Unexpected bank exploit balance");
        
        console.log("The legitimate customer deposits all their money to the bank");
        legitimateCustomer.depositToBank();
        Assert.equal(address(legitimateCustomer).balance, 0, "Legitimate customer should have no balance now");
        Assert.equal(address(this).balance, 0, "The test contract should have no balance now");

        console.log("Initialization succeeded");
    }

    function attack() external onlyOwner nonReentrant {
        Assert.equal(address(legitimateCustomer).balance, 0, "Unexpected customer balance");
        Assert.equal(address(bankExploit).balance, 1000 wei, "Unexpected bank exploit balance");
        Assert.equal(address(this).balance, 0, "Unexpected test contract balance");
        
        console.log("Exploiting the bank...");
        bankExploit.attackBank();
        Assert.equal(address(legitimateCustomer).balance, 0, "Unexpected customer balance");
        Assert.equal(address(bankExploit).balance, 2000 wei, "The bank exploit contract should now have twice the balance");
        Assert.equal(address(this).balance, 0, "Unexpected test contract balance");
        console.log("The exploit contract got twice of its amount back");
        
        console.log("Withdrawing money from the exploit contract");
        bankExploit.withdrawAll();
        Assert.equal(address(legitimateCustomer).balance, 0, "Unexpected customer balance");
        Assert.equal(address(bankExploit).balance, 0, "Unexpected bank exploit balance");
        Assert.equal(address(this).balance, 2000 wei, "The test contract should now have all the money from the bank");
        console.log("Attack succeeded");
        
        console.log("Returning money back to the test owner...");
        (bool success,) = owner().call{value: address(this).balance}("");
        require(success);
        console.log("Done.");
    }
}
